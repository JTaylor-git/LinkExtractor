Sprint 8: Team & RBAC (2 Weeks)

Goal: Introduce user accounts, role‑based access control, and project‑sharing so teams can collaborate securely.
📝 User Stories

    User Registration & Login

        As a new user, I want to register and log in with email/password and receive a JWT so I can authenticate requests.

    Roles & Permissions

        As an admin, I want “admin” and “editor” roles:

            Admin can manage users, projects, and global settings.

            Editor can view and run scrapes on projects they’re shared on.

    Project Sharing

        As an owner, I want to share a project with another user at either “editor” or “viewer” level so they can collaborate or view only.

    Enforced RBAC

        As a dev, secure REST endpoints so only users with proper role/project access can call them.

    CLI & UI

        As a power‑user, use clippr user create, clippr user list, clippr project share <projectId> <userEmail> <role> in CLI.

        As a user, see an Admin → Users page to manage users, and a Project → Share dialog to invite collaborators.

✔ Acceptance Criteria

    Auth Routes:

        POST /api/auth/register → { token }

        POST /api/auth/login → { token }

    User Routes (admin only):

        GET /api/users → list all users

        DELETE /api/users/:uid

    Project‑Sharing Routes:

        POST /api/projects/:pid/share { email, role } → grant access

        GET /api/projects/:pid/share → list shared users and roles

        DELETE /api/projects/:pid/share/:uid → revoke access

    RBAC Middleware protects all routes:

        Unauthenticated requests → 401

        Unauthorized → 403

    CLI Commands implemented and tested.

    UI Pages rendered with SvelteKit:

        /admin/users: list, create, delete users.

        /projects/[pid]/share: list collaborators, invite by email, set role, revoke.

📂 File Structure & Tasks

/api
 └─ src
    ├─ engine
    │   └─ UserService.ts         # manage users/auth/token/project access
    ├─ server
    │   ├─ rest
    │   │   ├─ auth.routes.ts
    │   │   ├─ users.routes.ts
    │   │   ├─ share.routes.ts
    │   │   └─ index.ts
    │   └─ middleware
    │       └─ authMiddleware.ts  # JWT validation & role/project checks

 /tests
 └─ api
    └─ rest
       ├─ auth.routes.test.ts
       ├─ users.routes.test.ts
       └─ share.routes.test.ts

/cli
 └─ src
    └─ commands
       ├─ user.ts                # create, list users
       └─ project-share.ts       # share/unshare projects

/web
 └─ src
    ├─ lib
    │   └─ components
    │       ├─ UserList.svelte
    │       └─ ProjectShare.svelte
    └─ routes
       ├─ admin
       │   └─ users
       │       └─ +page.svelte
       └─ projects
           └─ [pid]
               └─ share
                   └─ +page.svelte

1) UserService.ts

// api/src/engine/UserService.ts
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { v4 as uuidv4 } from 'uuid';

export type Role = 'admin' | 'editor' | 'viewer';
export interface User {
  id: string;
  email: string;
  passwordHash: string;
  role: Role;
  // Map of projectId→Role for shared access
  projects: Record<string, Role>;
}

// In‑memory store (swap for DB later)
const users = new Map<string, User>();

const JWT_SECRET = process.env.JWT_SECRET || 'clippr_secret';
const SALT_ROUNDS = 10;

export class UserService {
  /** Register new user as 'editor' by default */
  static async register(email: string, password: string): Promise<string> {
    if ([...users.values()].find(u => u.email === email)) {
      throw new Error('Email already in use');
    }
    const id = uuidv4();
    const hash = await bcrypt.hash(password, SALT_ROUNDS);
    users.set(id, { id, email, passwordHash: hash, role: 'editor', projects: {} });
    return UserService.signToken(id);
  }

  /** Verify credentials & return token */
  static async login(email: string, password: string): Promise<string> {
    const user = [...users.values()].find(u => u.email === email);
    if (!user || !(await bcrypt.compare(password, user.passwordHash))) {
      throw new Error('Invalid credentials');
    }
    return UserService.signToken(user.id);
  }

  /** List all users (admin only) */
  static list(): Omit<User,'passwordHash'>[] {
    return [...users.values()].map(({ passwordHash, ...u }) => u);
  }

  /** Delete user */
  static delete(userId: string): void {
    users.delete(userId);
  }

  /** Share project with user by email */
  static share(projectId: string, email: string, role: Role): void {
    const user = [...users.values()].find(u => u.email === email);
    if (!user) throw new Error('User not found');
    user.projects[projectId] = role;
  }

  /** Unshare project */
  static unshare(projectId: string, userId: string): void {
    const user = users.get(userId);
    if (user) delete user.projects[projectId];
  }

  /** List shares for a project */
  static listShares(projectId: string): { userId: string; email: string; role: Role }[] {
    return [...users.values()]
      .filter(u => u.projects[projectId])
      .map(u => ({ userId: u.id, email: u.email, role: u.projects[projectId] }));
  }

  /** Generate JWT */
  private static signToken(userId: string): string {
    return jwt.sign({ sub: userId }, JWT_SECRET, { expiresIn: '7d' });
  }

  /** Validate JWT and return user */
  static verifyToken(token: string): User {
    const payload = jwt.verify(token, JWT_SECRET) as any;
    const user = users.get(payload.sub);
    if (!user) throw new Error('User not found');
    return user;
  }
}

2) Auth Middleware

// api/src/server/middleware/authMiddleware.ts
import { Request, Response, NextFunction } from 'express';
import { UserService, Role } from '../../engine/UserService.js';

export interface AuthedRequest extends Request {
  user: ReturnType<typeof UserService.verifyToken>;
}

// Attach `req.user`
export function requireAuth(req: Request, res: Response, next: NextFunction) {
  try {
    const auth = req.headers.authorization?.split(' ')[1] || '';
    const user = UserService.verifyToken(auth);
    (req as AuthedRequest).user = user;
    next();
  } catch {
    res.sendStatus(401);
  }
}

// Check for global admin role
export function requireAdmin(req: Request, res: Response, next: NextFunction) {
  const user = (req as AuthedRequest).user;
  if (user.role !== 'admin') return res.sendStatus(403);
  next();
}

// Check project‑level access
export function requireProjectRole(minRole: Role) {
  return (req: Request, res: Response, next: NextFunction) => {
    const user = (req as AuthedRequest).user;
    const pid = req.params.pid;
    // Owners (role=admin) always allowed
    if (user.role === 'admin') return next();
    const projRole = user.projects[pid];
    const order: Role[] = ['viewer','editor','admin'];
    if (projRole && order.indexOf(projRole) >= order.indexOf(minRole)) {
      return next();
    }
    return res.sendStatus(403);
  };
}

3) REST Routes
a) auth.routes.ts

// api/src/server/rest/auth.routes.ts
import { Router } from 'express';
import { UserService } from '../../engine/UserService.js';

const router = Router();

// POST /api/auth/register
router.post('/register', async (req, res) => {
  try {
    const { email, password } = req.body;
    const token = await UserService.register(email, password);
    res.json({ token });
  } catch (err:any) {
    res.status(400).json({ error: err.message });
  }
});

// POST /api/auth/login
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const token = await UserService.login(email, password);
    res.json({ token });
  } catch (err:any) {
    res.status(400).json({ error: err.message });
  }
});

export default router;

b) users.routes.ts (admin only)

// api/src/server/rest/users.routes.ts
import { Router } from 'express';
import { UserService } from '../../engine/UserService.js';
import { requireAuth, requireAdmin } from '../middleware/authMiddleware.js';

const router = Router();
router.use(requireAuth, requireAdmin);

// GET /api/users
router.get('/', (_req, res) => {
  res.json(UserService.list());
});

// DELETE /api/users/:uid
router.delete('/:uid', (req, res) => {
  UserService.delete(req.params.uid);
  res.sendStatus(204);
});

export default router;

c) share.routes.ts

// api/src/server/rest/share.routes.ts
import { Router } from 'express';
import { UserService } from '../../engine/UserService.js';
import { requireAuth, requireProjectRole } from '../middleware/authMiddleware.js';

const router = Router();

// All routes require basic auth
router.use(requireAuth);

// POST /api/projects/:pid/share { email, role }
router.post(
  '/projects/:pid/share',
  requireProjectRole('editor'),
  (req, res) => {
    const { email, role } = req.body;
    try {
      UserService.share(req.params.pid, email, role);
      res.sendStatus(204);
    } catch (err:any) {
      res.status(400).json({ error: err.message });
    }
  }
);

// GET /api/projects/:pid/share
router.get(
  '/projects/:pid/share',
  requireProjectRole('viewer'),
  (req, res) => {
    res.json(UserService.listShares(req.params.pid));
  }
);

// DELETE /api/projects/:pid/share/:uid
router.delete(
  '/projects/:pid/share/:uid',
  requireProjectRole('editor'),
  (req, res) => {
    UserService.unshare(req.params.pid, req.params.uid);
    res.sendStatus(204);
  }
);

export default router;

d) Mount Routes in index.ts

// api/src/server/rest/index.ts
import express from 'express';
import authRoutes from './auth.routes.js';
import usersRoutes from './users.routes.js';
import projectRoutes from './project.routes.js';
import taskRoutes from './task.routes.js';
import shareRoutes from './share.routes.js';
// … other imports …

export function createRestApp() {
  const app = express().use(express.json());

  app.use('/api/auth', authRoutes);
  app.use('/api/users', usersRoutes);
  app.use('/api/projects', projectRoutes);
  app.use('/api', taskRoutes, shareRoutes);
  // … other mounts …

  return app;
}

4) CLI Commands
a) user.ts

// cli/src/commands/user.ts
import { Command } from 'commander';
import axios from 'axios';

const API = process.env.CLIPPR_API || 'http://localhost:4000/api';

export const userCmd = new Command('user')
  .description('Manage users');

// user create
userCmd
  .command('create <email> <password>')
  .description('Register new user')
  .action(async (email, password) => {
    const res = await axios.post(`${API}/auth/register`, { email, password });
    console.log('Token:', res.data.token);
  });

// user list
userCmd
  .command('list')
  .description('List all users (admin only)')
  .action(async () => {
    const res = await axios.get(`${API}/users`);
    console.table(res.data);
  });

// user delete
userCmd
  .command('delete <userId>')
  .description('Delete a user (admin only)')
  .action(async (uid) => {
    await axios.delete(`${API}/users/${uid}`);
    console.log('Deleted', uid);
  });

b) project-share.ts

// cli/src/commands/project-share.ts
import { Command } from 'commander';
import axios from 'axios';

const API = process.env.CLIPPR_API || 'http://localhost:4000/api';

export const shareCmd = new Command('project-share')
  .description('Share a project with a user');

// share
shareCmd
  .command('add <projectId> <email> <role>')
  .description('Share project as viewer|editor')
  .action(async (pid, email, role) => {
    await axios.post(`${API}/projects/${pid}/share`, { email, role });
    console.log(`Shared ${pid} with ${email} as ${role}`);
  });

// list
shareCmd
  .command('list <projectId>')
  .description('List shares for a project')
  .action(async (pid) => {
    const res = await axios.get(`${API}/projects/${pid}/share`);
    console.table(res.data);
  });

// revoke
shareCmd
  .command('remove <projectId> <userId>')
  .description('Revoke access')
  .action(async (pid, uid) => {
    await axios.delete(`${API}/projects/${pid}/share/${uid}`);
    console.log(`Revoked ${uid} from ${pid}`);
  });

    Mount these in cli/src/index.ts with program.addCommand(userCmd) and program.addCommand(shareCmd).

5) Web UI
a) UserList.svelte

<!-- web/src/lib/components/UserList.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  let users = [];
  async function load() {
    const res = await fetch('/api/users');
    users = await res.json();
  }
  async function remove(id: string) {
    await fetch(`/api/users/${id}`, { method: 'DELETE' });
    await load();
  }
  onMount(load);
</script>

<table class="min-w-full bg-shodan-surface text-shodan-text">
  <thead><tr><th>Email</th><th>Role</th><th>Actions</th></tr></thead>
  <tbody>
    {#each users as u}
      <tr>
        <td>{u.email}</td>
        <td>{u.role}</td>
        <td>
          <button on:click={() => remove(u.id)}>Delete</button>
        </td>
      </tr>
    {/each}
  </tbody>
</table>

b) ProjectShare.svelte

<!-- web/src/lib/components/ProjectShare.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  export let projectId: string;
  let shares = [];
  let email = '', role = 'viewer';

  async function load() {
    shares = await fetch(`/api/projects/${projectId}/share`).then(r=>r.json());
  }
  async function add() {
    await fetch(`/api/projects/${projectId}/share`, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ email, role })
    });
    email=''; role='viewer';
    await load();
  }
  async function remove(uid:string) {
    await fetch(`/api/projects/${projectId}/share/${uid}`, { method:'DELETE' });
    await load();
  }
  onMount(load);
</script>

<div class="p-4 bg-shodan-surface rounded">
  <h3>Collaborators</h3>
  <ul>
    {#each shares as s}
      <li>{s.email} ({s.role})
        <button on:click={()=>remove(s.userId)}>Revoke</button>
      </li>
    {/each}
  </ul>

  <h4>Invite</h4>
  <input bind:value={email} placeholder="user email" />
  <select bind:value={role}>
    <option value="viewer">Viewer</option>
    <option value="editor">Editor</option>
  </select>
  <button on:click={add}>Invite</button>
</div>

c) Routes

<!-- web/src/routes/admin/users/+page.svelte -->
<script>
  import UserList from '$lib/components/UserList.svelte';
</script>
<h2>Users</h2>
<UserList />

<!-- web/src/routes/projects/[pid]/share/+page.svelte -->
<script lang="ts">
  import { page } from '$app/stores';
  import ProjectShare from '$lib/components/ProjectShare.svelte';
  $: pid = $page.params.pid;
</script>
<h2>Share Project {$page.params.pid}</h2>
<ProjectShare {projectId}=pid />

✅ Next Steps

    Merge all backend files, middleware, and tests; run npm test in /api.

    Install new dependencies:

cd api
npm install bcrypt jsonwebtoken uuid
cd ../cli
npm install axios commander

Configure JWT_SECRET in your environment.

Mount CLI commands; rebuild the CLI binary.

Run frontend and navigate to /admin/users and /projects/[pid]/share to verify.

Test end‑to‑end:

    Register two users, log in to get tokens.

    Create a project as user A, share with user B.

    Log in as B and confirm B can list/run scrapes on that project but not others.