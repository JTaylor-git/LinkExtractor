Goal: Provide a comprehensive analytics dashboard with multiple chartsâ€”requests over time, per-domain latency, resource-type breakdown, and an error heatmapâ€”using a REST endpoint and a Svelte front-end component.
ðŸ“ User Stories

    Requests Over Time

        As a user, I want a line chart showing the number of requests per hour (last 24â€¯hours).

    Perâ€‘Domain Latency

        As a user, I want a bar chart of average latency per domain.

    Resourceâ€‘Type Breakdown

        As a user, I want a pie chart showing the distribution of resource types fetched (HTML, JSON, images, etc.).

    Error Heatmap

        As a user, I want a heatmap table of URLâ€‘pattern â†’ error count.

    Backend Service

        As a dev, I need an AnalyticsService to generate or fetch aggregated metrics.

    REST API

        As a dev, I want GET /api/dashboard/analytics to return all these datasets.

    Component & Route

        As a dev, I need AnalyticsTab.svelte (using Chart.js) and a /analytics page.

âœ” Acceptance Criteria

    GET /api/dashboard/analytics returns:

    {
      "timeseries": [{"timestamp":"ISO8601","count":number},â€¦],
      "domainLatency":[{"domain":string,"avgLatency":number},â€¦],
      "resourceBreakdown":[{"type":string,"count":number},â€¦],
      "errorHeatmap":[{"pattern":string,"errors":number},â€¦]
    }

    Charts render correctly with default Chart.js colors.

    Error heatmap displays a table with cell background intensity proportional to error count.

    Endpoint and component operate without runtime errors; basic unit tests pass.

ðŸ“‚ File Structure

/api
 â””â”€ src
    â”œâ”€ engine
    â”‚   â””â”€ AnalyticsService.ts
    â””â”€ server
       â””â”€ rest
          â”œâ”€ analytics.routes.ts
          â””â”€ index.ts   (mount route)

/tests
 â””â”€ api
    â””â”€ rest
       â””â”€ analytics.routes.test.ts

/web
 â””â”€ src
    â”œâ”€ lib
    â”‚   â””â”€ components
    â”‚      â””â”€ AnalyticsTab.svelte
    â””â”€ routes
       â””â”€ analytics
          â””â”€ +page.svelte

1) Backend: AnalyticsService.ts

// api/src/engine/AnalyticsService.ts
export interface TimePoint { timestamp: string; count: number; }
export interface DomainLatency { domain: string; avgLatency: number; }
export interface ResourceBreakdown { type: string; count: number; }
export interface ErrorHeat { pattern: string; errors: number; }

export class AnalyticsService {
  static getAnalytics(): {
    timeseries: TimePoint[];
    domainLatency: DomainLatency[];
    resourceBreakdown: ResourceBreakdown[];
    errorHeatmap: ErrorHeat[];
  } {
    // Stub data for Sprint 7
    const now = Date.now();
    const timeseries = Array.from({ length: 24 }).map((_, i) => ({
      timestamp: new Date(now - (23 - i) * 3600_000).toISOString(),
      count: Math.floor(Math.random() * 100)
    }));

    const domains = ['example.com', 'bluegolf.com', 'api.clippr.com'];
    const domainLatency = domains.map(d => ({
      domain: d,
      avgLatency: parseFloat((Math.random() * 1000).toFixed(1))
    }));

    const types = ['html', 'json', 'image', 'css', 'js'];
    const resourceBreakdown = types.map(t => ({
      type: t,
      count: Math.floor(Math.random() * 500)
    }));

    const patterns = ['/overview.htm', '/course/', '/api/'];
    const errorHeatmap = patterns.map(p => ({
      pattern: p,
      errors: Math.floor(Math.random() * 20)
    }));

    return { timeseries, domainLatency, resourceBreakdown, errorHeatmap };
  }
}

2) REST Route: analytics.routes.ts

// api/src/server/rest/analytics.routes.ts
import { Router } from 'express';
import { AnalyticsService } from '../../engine/AnalyticsService.js';

const router = Router();

/**
 * GET /api/dashboard/analytics
 */
router.get('/dashboard/analytics', (_req, res) => {
  const data = AnalyticsService.getAnalytics();
  res.json(data);
});

export default router;

Mount it in your REST index:

// api/src/server/rest/index.ts
import analyticsRoutes from './analytics.routes.js';
// â€¦
export function createRestApp() {
  const app = express();
  // â€¦ existing mounts â€¦
  app.use('/api', analyticsRoutes);
  return app;
}

3) Test: analytics.routes.test.ts

// tests/api/rest/analytics.routes.test.ts
import request from 'supertest';
import { createRestApp } from '../../../api/src/server/rest/index.js';

describe('GET /api/dashboard/analytics', () => {
  const app = createRestApp();

  it('returns full analytics payload', async () => {
    const res = await request(app).get('/api/dashboard/analytics');
    expect(res.status).toBe(200);
    const body = res.body;
    expect(Array.isArray(body.timeseries)).toBe(true);
    expect(body.timeseries.length).toBe(24);
    expect(Array.isArray(body.domainLatency)).toBe(true);
    expect(Array.isArray(body.resourceBreakdown)).toBe(true);
    expect(Array.isArray(body.errorHeatmap)).toBe(true);
    // Check structure of first element
    const ts = body.timeseries[0];
    expect(typeof ts.timestamp).toBe('string');
    expect(typeof ts.count).toBe('number');
  });
});

4) Frontend Component: AnalyticsTab.svelte

<!-- web/src/lib/components/AnalyticsTab.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  import Chart from 'chart.js/auto';

  interface TimePoint { timestamp: string; count: number; }
  interface DomainLatency { domain: string; avgLatency: number; }
  interface ResourceBreakdown { type: string; count: number; }
  interface ErrorHeat { pattern: string; errors: number; }

  let timeseries: TimePoint[] = [];
  let domainLatency: DomainLatency[] = [];
  let resourceBreakdown: ResourceBreakdown[] = [];
  let errorHeatmap: ErrorHeat[] = [];

  let lineCtx: HTMLCanvasElement;
  let barCtx: HTMLCanvasElement;
  let pieCtx: HTMLCanvasElement;

  async function load() {
    const res = await fetch('/api/dashboard/analytics');
    const data = await res.json();
    timeseries = data.timeseries;
    domainLatency = data.domainLatency;
    resourceBreakdown = data.resourceBreakdown;
    errorHeatmap = data.errorHeatmap;
    renderCharts();
  }

  function renderCharts() {
    // Line chart: requests over time
    new Chart(lineCtx, {
      type: 'line',
      data: {
        labels: timeseries.map(p => new Date(p.timestamp).getHours() + ':00'),
        datasets: [{ label: 'Requests', data: timeseries.map(p => p.count), fill: false }]
      }
    });

    // Bar chart: latency per domain
    new Chart(barCtx, {
      type: 'bar',
      data: {
        labels: domainLatency.map(d => d.domain),
        datasets: [{ label: 'Avg Latency (ms)', data: domainLatency.map(d => d.avgLatency) }]
      }
    });

    // Pie chart: resource type breakdown
    new Chart(pieCtx, {
      type: 'pie',
      data: {
        labels: resourceBreakdown.map(r => r.type),
        datasets: [{ data: resourceBreakdown.map(r => r.count) }]
      }
    });
  }

  onMount(load);
</script>

<style>
  .grid { display: grid; grid-template-columns: repeat(2,1fr); gap: 2rem; }
  canvas { background: var(--card); border-radius: 0.5rem; }
  .heatmap { margin-top: 2rem; }
  .heatmap table { width: 100%; border-collapse: collapse; }
  .heatmap td, .heatmap th { padding: 0.5rem; text-align: left; }
</style>

<div class="grid">
  <div>
    <h3>Requests Over Time</h3>
    <canvas bind:this={lineCtx}></canvas>
  </div>
  <div>
    <h3>Latency per Domain</h3>
    <canvas bind:this={barCtx}></canvas>
  </div>
  <div>
    <h3>Resource Breakdown</h3>
    <canvas bind:this={pieCtx}></canvas>
  </div>
</div>

<div class="heatmap">
  <h3>Error Heatmap</h3>
  <table>
    <thead><tr><th>URL Pattern</th><th>Errors</th></tr></thead>
    <tbody>
      {#each errorHeatmap as e}
        <tr style="background: rgba(255,0,0, {e.errors / Math.max(...errorHeatmap.map(x=>x.errors),1) * 0.5})">
          <td>{e.pattern}</td>
          <td>{e.errors}</td>
        </tr>
      {/each}
    </tbody>
  </table>
</div>

    Install Chart.js:

    cd web
    npm install chart.js

5) Route & Page: /analytics

<!-- web/src/routes/analytics/+page.svelte -->
<script>
  import AnalyticsTab from '$lib/components/AnalyticsTab.svelte';
</script>

<AnalyticsTab />

âœ… Next Steps

    Merge backend service, route, and tests; run npm test in /api.

    Merge front-end component and route; run npm run dev in /web.

    Visit http://localhost:3000/analytics to see all four charts and the heatmap.

    Review data alignment and tweak styling or chart options as needed.