Goal: Provide a dynamic plugin ecosystem allowing users to discover, install, enable, and uninstall authentication and parser plugins via CLI, REST API, and a UI.
📝 User Stories

    Marketplace Browsing

        As a user, I want to browse a list of available plugins (auth modules, parser modules) fetched from a remote manifest so I can choose what to install.

    Plugin Installation & Removal

        As a user, I want to install a plugin by name (which downloads and unpacks it into our /plugins folder) and uninstall it when I no longer need it.

    Enable/Disable

        As a user, I want to enable or disable installed plugins from the UI so my system only loads the ones I need.

    Plugin API

        As a dev, I want a PluginManager that exposes methods to list remote plugins, install/uninstall, and load enabled plugins into our system.

    CLI Integration

        As a power‑user, I want clippr plugin list, clippr plugin install <name>, and clippr plugin uninstall <name> commands.

    UI Integration

        As a user, I want a Plugins page in the web UI listing both “Available” and “Installed” plugins with Install/Uninstall toggles.

✔ Acceptance Criteria

    /api/plugins/marketplace returns the remote manifest JSON.

    /api/plugins (GET) returns installed plugins and their enabled status.

    /api/plugins/:name/install and /uninstall perform the action and update state.

    PluginManager persists installed plugins in plugins/ directory and /api/plugins.json.

    CLI commands mirror the REST API.

    UI shows a two‑column layout: available vs installed, with buttons.

    Installed plugins are loaded at server startup via PluginManager.loadEnabled().

📋 File Structure & Tasks

/api
 ├─ plugins
 │   ├─ manifest.remote.json      # remote marketplace manifest
 │   ├─ plugins.json              # local installed/enabled record
 │   └─ (plugin packages unpacked)
/ └─ src
    ├─ plugins
    │   ├─ PluginManager.ts
    └─ server
       └─ rest
          └─ plugin.routes.ts

/cli
 └─ src
    └─ commands
       └─ plugin.ts

/web
 └─ src
    └─ routes
       └─ plugins
          ├─ +page.svelte
          └─ PluginStore.svelte

1) PluginManager (API)

// api/src/plugins/PluginManager.ts
import fs from 'fs';
import path from 'path';
import axios from 'axios';
import decompress from 'decompress';

export interface RemotePlugin {
  name: string;
  description: string;
  version: string;
  tarballUrl: string;
  type: 'auth' | 'parser';
}

export interface InstalledPlugin {
  name: string;
  version: string;
  enabled: boolean;
  type: 'auth' | 'parser';
}

const ROOT = path.resolve(__dirname, '../../');
const PLUGINS_DIR = path.join(ROOT, 'plugins');
const LOCAL_MANIFEST = path.join(PLUGINS_DIR, 'plugins.json');
const REMOTE_MANIFEST = path.join(PLUGINS_DIR, 'manifest.remote.json');

export class PluginManager {
  static async fetchRemoteManifest(): Promise<RemotePlugin[]> {
    const remoteUrl = 'https://cdn.clippr.com/manifest.json';
    const res = await axios.get<RemotePlugin[]>(remoteUrl);
    // cache locally
    fs.mkdirSync(PLUGINS_DIR, { recursive: true });
    fs.writeFileSync(REMOTE_MANIFEST, JSON.stringify(res.data, null, 2));
    return res.data;
  }

  static getRemoteManifest(): RemotePlugin[] {
    if (!fs.existsSync(REMOTE_MANIFEST)) return [];
    return JSON.parse(fs.readFileSync(REMOTE_MANIFEST, 'utf8'));
  }

  static getLocalPlugins(): InstalledPlugin[] {
    if (!fs.existsSync(LOCAL_MANIFEST)) return [];
    return JSON.parse(fs.readFileSync(LOCAL_MANIFEST, 'utf8'));
  }

  static saveLocalPlugins(list: InstalledPlugin[]) {
    fs.mkdirSync(PLUGINS_DIR, { recursive: true });
    fs.writeFileSync(LOCAL_MANIFEST, JSON.stringify(list, null, 2));
  }

  static async install(name: string): Promise<InstalledPlugin> {
    const remote = this.getRemoteManifest().find(p => p.name === name);
    if (!remote) throw new Error(`Plugin ${name} not found`);
    const response = await axios.get<Buffer>(remote.tarballUrl, { responseType: 'arraybuffer' });
    const pluginDir = path.join(PLUGINS_DIR, name);
    fs.mkdirSync(pluginDir, { recursive: true });
    // unpack tarball into pluginDir
    await decompress(response.data, pluginDir);
    // update local manifest
    const locals = this.getLocalPlugins();
    const existing = locals.find(p => p.name === name);
    const entry: InstalledPlugin = {
      name, version: remote.version, enabled: true, type: remote.type
    };
    if (existing) {
      existing.version = remote.version;
      existing.enabled = true;
    } else {
      locals.push(entry);
    }
    this.saveLocalPlugins(locals);
    return entry;
  }

  static uninstall(name: string): void {
    const pluginDir = path.join(PLUGINS_DIR, name);
    if (fs.existsSync(pluginDir)) {
      fs.rmSync(pluginDir, { recursive: true, force: true });
    }
    const locals = this.getLocalPlugins().filter(p => p.name !== name);
    this.saveLocalPlugins(locals);
  }

  static enable(name: string): void {
    const locals = this.getLocalPlugins();
    const p = locals.find(p => p.name === name);
    if (p) p.enabled = true;
    this.saveLocalPlugins(locals);
  }

  static disable(name: string): void {
    const locals = this.getLocalPlugins();
    const p = locals.find(p => p.name === name);
    if (p) p.enabled = false;
    this.saveLocalPlugins(locals);
  }

  /** Load enabled plugins into the system */
  static loadEnabled(): void {
    const locals = this.getLocalPlugins().filter(p => p.enabled);
    for (const p of locals) {
      const modPath = path.join(PLUGINS_DIR, p.name);
      // each plugin must export default init(app) for auth or parse registration
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      const plugin = require(modPath).default;
      plugin(); // plugin initializes itself (hooks into our DI/engine)
    }
  }
}

    npm install axios decompress

2) REST Routes: plugin.routes.ts

// api/src/server/rest/plugin.routes.ts
import { Router } from 'express';
import { PluginManager, RemotePlugin, InstalledPlugin } from '../../plugins/PluginManager.js';

const router = Router();

// GET /api/plugins/marketplace
router.get('/marketplace', async (_req, res) => {
  const list = await PluginManager.fetchRemoteManifest();
  res.json(list as RemotePlugin[]);
});

// GET /api/plugins
router.get('/', (_req, res) => {
  const list = PluginManager.getLocalPlugins();
  res.json(list as InstalledPlugin[]);
});

// POST /api/plugins/:name/install
router.post('/:name/install', async (req, res) => {
  try {
    const plugin = await PluginManager.install(req.params.name);
    res.status(201).json(plugin);
  } catch (err: any) {
    res.status(400).json({ error: err.message });
  }
});

// POST /api/plugins/:name/uninstall
router.post('/:name/uninstall', (req, res) => {
  try {
    PluginManager.uninstall(req.params.name);
    res.status(204).end();
  } catch (err: any) {
    res.status(400).json({ error: err.message });
  }
});

// POST /api/plugins/:name/enable or /disable
router.post('/:name/enable', (req, res) => {
  PluginManager.enable(req.params.name);
  res.status(204).end();
});
router.post('/:name/disable', (req, res) => {
  PluginManager.disable(req.params.name);
  res.status(204).end();
});

export default router;

    Remember to mount in your REST index:

    app.use('/api/plugins', pluginRoutes);

3) CLI Commands: plugin.ts

// cli/src/commands/plugin.ts
import { Command } from 'commander';
import axios from 'axios';

const API = process.env.CLIPPR_API || 'http://localhost:4000/api';

export const pluginCmd = new Command('plugin')
  .description('Manage Clippr plugins')
  .command('list')
  .description('List available and installed plugins')
  .action(async () => {
    const [remote, local] = await Promise.all([
      axios.get(`${API}/plugins/marketplace`),
      axios.get(`${API}/plugins`)
    ]);
    console.log('Available:');
    remote.data.forEach((p: any) => {
      console.log(`  • ${p.name}@${p.version} – ${p.description}`);
    });
    console.log('\nInstalled:');
    local.data.forEach((p: any) => {
      console.log(`  • ${p.name}@${p.version} [${p.enabled?'enabled':'disabled'}]`);
    });
  });

pluginCmd
  .command('install <name>')
  .description('Install a plugin')
  .action(async name => {
    const res = await axios.post(`${API}/plugins/${name}/install`);
    console.log(`Installed ${res.data.name}@${res.data.version}`);
  });

pluginCmd
  .command('uninstall <name>')
  .description('Uninstall a plugin')
  .action(async name => {
    await axios.post(`${API}/plugins/${name}/uninstall`);
    console.log(`Uninstalled ${name}`);
  });

pluginCmd
  .command('enable <name>')
  .description('Enable an installed plugin')
  .action(async name => {
    await axios.post(`${API}/plugins/${name}/enable`);
    console.log(`Enabled ${name}`);
  });

pluginCmd
  .command('disable <name>')
  .description('Disable an installed plugin')
  .action(async name => {
    await axios.post(`${API}/plugins/${name}/disable`);
    console.log(`Disabled ${name}`);
  });

    Mount this in cli/src/index.ts:

    import { pluginCmd } from './commands/plugin.js';
    program.addCommand(pluginCmd);

4) Web UI: Plugin Store
a) PluginStore.svelte

<!-- web/src/routes/plugins/PluginStore.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  let available = [];
  let installed = [];
  async function refresh() {
    available = await fetch('/api/plugins/marketplace').then(r=>r.json());
    installed = await fetch('/api/plugins').then(r=>r.json());
  }
  function isInstalled(name) {
    return installed.find(p=>p.name===name);
  }
  async function install(name) {
    await fetch(`/api/plugins/${name}/install`, { method:'POST' });
    await refresh();
  }
  async function uninstall(name) {
    await fetch(`/api/plugins/${name}/uninstall`, { method:'POST' });
    await refresh();
  }
  async function toggle(name) {
    const p = isInstalled(name);
    await fetch(`/api/plugins/${name}/${p.enabled?'disable':'enable'}`, { method:'POST' });
    await refresh();
  }
  onMount(refresh);
</script>

<style>
  .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
  .card { padding:1rem; background:var(--card); border-radius:0.5rem; }
  button { margin-top:0.5rem; }
</style>

<div class="grid">
  <div>
    <h2>Available Plugins</h2>
    {#each available as p}
      <div class="card">
        <strong>{p.name}@{p.version}</strong>
        <p>{p.description}</p>
        {#if !isInstalled(p.name)}
          <button on:click={()=>install(p.name)}>Install</button>
        {:else}
          <button disabled>Installed</button>
        {/if}
      </div>
    {/each}
  </div>

  <div>
    <h2>Installed Plugins</h2>
    {#each installed as p}
      <div class="card">
        <strong>{p.name}@{p.version}</strong>
        <p>Type: {p.type}</p>
        <button on:click={()=>toggle(p.name)}>
          {p.enabled ? 'Disable' : 'Enable'}
        </button>
        <button on:click={()=>uninstall(p.name)}>Uninstall</button>
      </div>
    {/each}
  </div>
</div>

b) +page.svelte

<!-- web/src/routes/plugins/+page.svelte -->
<script>
  import PluginStore from './PluginStore.svelte';
</script>

<PluginStore />

✅ Next Steps

    Merge into the monorepo.

    Install dependencies:

cd api
npm install axios decompress
cd ../cli
npm install axios commander
cd ../web
npm install

Mount REST routes and CLI commands, then restart services.

Test via CLI:

clippr plugin list
clippr plugin install my-auth-plugin
clippr plugin uninstall my-auth-plugin

Visit http://localhost:3000/plugins in your UI to confirm the marketplace page.

Verify that installed plugins auto‑load at server startup via PluginManager.loadEnabled().